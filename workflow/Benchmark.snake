from itertools import product

configfile: "configs/config.yaml"

include: "rules/alignment.smk"
include: "rules/pipeline.smk"

localrules:
    plots, resources, accuracy_tables

MODES = config.get("modes", ("align"))
ENDS = config.get("ends", ("pe"))

DATASET_CONFIGS = expand_datasets(config.get("datasets", []))
DATASET_IDS = list(DATASET_CONFIGS.keys())

VERSIONS = {}
for version in config.get("versions", []):
    key = version["commit"]
    if arg := version.get("arguments", ""):
        key += "-" + arg.replace(" ", "").replace("-", "").replace("=", "")
    VERSIONS[key] = {
        "commit": version["commit"],
        "arguments": f" {arg}" if arg else "",
        "name": version["name"],
        "color": version["color"],
        "binary": f"bin/strobealign/{version['commit']}",
    }

PROGRAMS = expand("strobealign-{key}", key=VERSIONS.keys())
if config["programs"]:
    PROGRAMS.extend(config["programs"])
PLOTS = ("accuracy", "aligned", "time", "memory")


rule final:
    input:
        expand("csv/{prog}/{dataset_id}/pe.bam.resources.csv", prog=PROGRAMS, dataset_id=DATASET_IDS),
        # expand("runs/{prog}/{dataset_id}/pe.bam", prog=PROGRAMS, genome=GENOMES, read_length=READ_LENGTHS),
        expand("result/{dataset_id}/accuracy_table.tsv", dataset_id=DATASET_IDS)


rule run_adna_accuracy:
    output:
        "csv/{prog}/{dataset_id}/accuracy.tsv"
    input:
        gt="datasets/{dataset_id}/ref_ground_truth.bed",
        bam="runs/{prog}/{dataset_id}/se.bam"
    shell:
        "python workflow/scripts/adna_accuracy.py --ground-truth {input.gt} --predicted {input.bam} > {output}"


rule accuracy_tables:
    output:
        "result/{dataset_id}/accuracy_table.tsv"
    input:
        expand("csv/{prog}/{{dataset_id}}/accuracy.tsv", prog=PROGRAMS)
    params:
        programs=PROGRAMS,
        config=config
    run:
        import csv

        tool_names = {}
        for key, version in VERSIONS.items():
            prog_name = f"strobealign-{key}"
            tool_names[prog_name] = version["name"]

        for prog in config.get("programs", []):
            tool_names[prog] = prog

        with open(output[0], 'w', newline='') as outfile:
            writer = csv.writer(outfile, delimiter='\t')
            writer.writerow([
                "Tool",
                "% Mapped endogenous reads",
                "% Accuracy (endogenous only)",
                "% Mapped bacterial reads",
                "% Mapped contaminated reads"
            ])

            for prog, input_file in zip(params.programs, input):
                tool_name = tool_names.get(prog, prog)
                with open(input_file) as f:
                    values = f.read().strip().split('\t')
                    writer.writerow([tool_name] + values)


rule resources:
    output:
        csv="csv/{prog}/{dataset_id}/{ends}.{bampaf}.resources.csv"
    input:
        log="runs/{prog}/{dataset_id}/{ends}.{bampaf}.log",
    params:
        typ=lambda wildcards: "map" if wildcards.bampaf == "paf" else "align",
        genome=lambda wc: f"genomes/{get_dataset_param(wc, 'endogenous_genome')}",
        read_len=lambda wc: f"genomes/{get_dataset_param(wc, 'read_length')}"
    shell:
        """
        echo -n {wildcards.prog},{params.typ},{params.genome},{wildcards.ends},{params.read_len}, > {output.csv}.tmp
        user_time=$(awk '/User time/ {{print $NF}}' {input.log})
        memory=$(awk '/Maximum resident/ {{print $NF/1048576}}' {input.log})
        indexing_time=$(awk '/Total time indexing:/ {{print $4}}' {input.log})
        mapping_time=$(awk '/Total time mapping:/ {{print $4}}' {input.log})
        if test -z "${{mapping_time}}"; then mapping_time=$(sed -n -e 's|.* Real time: \\([1-9][0-9.]*\\) sec.*|\\1|p' {input.log}); fi
        if test -z "${{mapping_time}}"; then mapping_time=$(awk '/^Processing query/ && $3 >= 10000 && t == 0 {{t=substr($5, 1, length($5)-1);}}; /^Done in/ {{total=substr($3, 1, length($3)-2)}}; END{{print total-t}}' {input.log}); fi
        echo ,${{mapping_time}},${{memory}} >> {output}.tmp
        mv {output.csv}.tmp {output.csv}
        """
